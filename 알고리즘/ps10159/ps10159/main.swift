//
//  main.swift
//  ps10159
//
//  Created by Jung peter on 3/10/23.
//

/*
 문제
 무게가 서로 다른 N 개의 물건이 있다. 각 물건은 1부터 N 까지 번호가 매겨져 있다. 우리는 일부 물건 쌍에 대해서 양팔 저울로 어떤 것이 무거운 것인지를 측정한 결과표를 가지고 있다. 이 결과표로부터 직접 측정하지 않은 물건 쌍의 비교 결과를 알아낼 수도 있고 알아내지 못할 수도 있다. 예를 들어, 총 6개의 물건이 있고, 다음 5개의 비교 결과가 주어졌다고 가정하자. ([1]은 1번 물건의 무게를 의미한다.)

 [1]>[2], [2]>[3], [3]>[4], [5]>[4], [6]>[5]

 우리는 [2]>[3], [3]>[4]로부터 [2]>[4]라는 것을 알 수 있다. 하지만, 물건 2와 물건 6을 비교하는 경우, 앞서의 결과만으로는 어느 것이 무거운지 알 수 없다. 이와 같이, 물건 2는 물건 1, 3, 4와의 비교 결과는 알 수 있지만, 물건 5, 6과의 비교 결과는 알 수 없다. 물건 4는 모든 다른 물건과의 비교 결과를 알 수 있다.

 비교 결과가 모순되는 입력은 없다고 가정한다. 위 예제의 기존 측정 결과에 [3]>[1]이 추가되었다고 가정하자. 이 경우 [1]>[2], [2]>[3]이므로 우리는 [1]>[3]이라는 것을 예측할 수 있는데, 이는 기존에 측정된 결과 [3]>[1]과 서로 모순이므로 이러한 입력은 가능하지 않다.

 물건의 개수 N 과 일부 물건 쌍의 비교 결과가 주어졌을 때, 각 물건에 대해서 그 물건과의 비교 결과를 알 수 없는 물건의 개수를 출력하는 프로그램을 작성하시오.
 */

/*
 풀이
 
 처음에 풀지 못했음, 처음에 생각했던것은 뭔가 재귀로 내려가는것 같은데, 하나의 배열에 root가 많은 것 같아서 UnionFind? 인가 생각을 했는데,
 tree처럼 단방향이 아니라서, 그래프를 생각함.
 근데 여기서 사고가 멈춰버림 -> 다른사람들이 위상정렬로 Root노드 찾고, dfs로 전체 파악할수있을것이라는 다른 생각이 일리가 있음
 
 그리고 플로이드 와샬이라는 것을 확인했을때 뭔가 모든 정점에 대해서 간선 조사를 하는 것이니 일리가 있다 생각했고, 그리고 우선순위가 크게 상관이 없겠다는 생각을 함, 그냥 단순히 비교가 가능한가? 이런거였으니깐
 
    중요한건 비교가 가능한거냐니깐, 체크만 되어있으면 되는거였음
    그래서 0이 아닌 것은 전부 비교가 가능하다고 생각을 하면되는것임
    그다음은 비교할수없는 것을 print하는거니깐 n-cnt
 
 */


import Foundation

let n = Int(readLine()!)!
let m = Int(readLine()!)!
var board = [[Int]](repeating: [Int](repeating: 0, count: n+1), count: n+1)
for i in 1...n {
  board[i][i] = 1
}

for _ in 0..<m {
  let temp = readLine()!.split(separator: " ").map { Int(String($0))!}
  board[temp[0]][temp[1]] = 1
  board[temp[1]][temp[0]] = -1
}

for k in 1...n {
  for y in 1...n {
    for x in 1...n {
      if (board[y][k] == board[k][x] && board[y][k] != 0) {
        board[y][x] = board[y][k]
      }
    }
  }
}


for y in 1...n {
  var cnt = 0
  for x in 1...n {
    if board[y][x] != 0 { cnt += 1}
  }
  print(n - cnt)
}






